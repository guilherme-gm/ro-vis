// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: items.sql

package dao

import (
	"context"
	"database/sql"
)

const countChangedItemsInPatch = `-- name: CountChangedItemsInPatch :one
SELECT COUNT(*)
FROM ` + "`" + `item_history` + "`" + `
WHERE ` + "`" + `update` + "`" + ` = ?
`

func (q *Queries) CountChangedItemsInPatch(ctx context.Context, update string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countChangedItemsInPatch, update)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countItems = `-- name: CountItems :one
SELECT COUNT(*)
FROM ` + "`" + `items` + "`" + `
INNER JOIN ` + "`" + `item_history` + "`" + ` ON ` + "`" + `items` + "`" + `.` + "`" + `latest_history_id` + "`" + ` = ` + "`" + `item_history` + "`" + `.` + "`" + `history_id` + "`" + `
WHERE ` + "`" + `items` + "`" + `.` + "`" + `deleted` + "`" + ` = FALSE
`

func (q *Queries) CountItems(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countItems)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getChangedItems = `-- name: GetChangedItems :many
SELECT current.history_id, current.previous_history_id, current.item_id, current.file_version, current.` + "`" + `update` + "`" + `, current.identified_name, current.identified_description, current.identified_sprite, current.unidentified_name, current.unidentified_description, current.unidentified_sprite, current.slot_count, current.is_book, current.can_use_buying_store, current.card_prefix, current.card_is_postfix, current.card_illustration, current.class_num, current.is_costume, current.effect_id, current.package_id, current.move_info, previous.history_id, previous.previous_history_id, previous.item_id, previous.file_version, previous.` + "`" + `update` + "`" + `, previous.identified_name, previous.identified_description, previous.identified_sprite, previous.unidentified_name, previous.unidentified_description, previous.unidentified_sprite, previous.slot_count, previous.is_book, previous.can_use_buying_store, previous.card_prefix, previous.card_is_postfix, previous.card_illustration, previous.class_num, previous.is_costume, previous.effect_id, previous.package_id, previous.move_info, latest.update lastUpdate
FROM ` + "`" + `item_history` + "`" + ` current
LEFT JOIN ` + "`" + `previous_item_history_vw` + "`" + ` previous ON ` + "`" + `previous` + "`" + `.` + "`" + `history_id` + "`" + ` = ` + "`" + `current` + "`" + `.` + "`" + `previous_history_id` + "`" + `
LEFT JOIN ` + "`" + `items` + "`" + ` latest_id ON ` + "`" + `latest_id` + "`" + `.` + "`" + `item_id` + "`" + ` = ` + "`" + `current` + "`" + `.` + "`" + `item_id` + "`" + `
LEFT JOIN ` + "`" + `item_history` + "`" + ` latest ON ` + "`" + `latest_id` + "`" + `.` + "`" + `latest_history_id` + "`" + ` = ` + "`" + `latest` + "`" + `.` + "`" + `history_id` + "`" + `
WHERE ` + "`" + `current` + "`" + `.` + "`" + `update` + "`" + ` = ?
ORDER BY ` + "`" + `current` + "`" + `.` + "`" + `history_id` + "`" + `
LIMIT ?, ?
`

type GetChangedItemsParams struct {
	Update string
	Offset int32
	Limit  int32
}

type GetChangedItemsRow struct {
	ItemHistory           ItemHistory
	PreviousItemHistoryVw PreviousItemHistoryVw
	Lastupdate            sql.NullString
}

func (q *Queries) GetChangedItems(ctx context.Context, arg GetChangedItemsParams) ([]GetChangedItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getChangedItems, arg.Update, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChangedItemsRow
	for rows.Next() {
		var i GetChangedItemsRow
		if err := rows.Scan(
			&i.ItemHistory.HistoryID,
			&i.ItemHistory.PreviousHistoryID,
			&i.ItemHistory.ItemID,
			&i.ItemHistory.FileVersion,
			&i.ItemHistory.Update,
			&i.ItemHistory.IdentifiedName,
			&i.ItemHistory.IdentifiedDescription,
			&i.ItemHistory.IdentifiedSprite,
			&i.ItemHistory.UnidentifiedName,
			&i.ItemHistory.UnidentifiedDescription,
			&i.ItemHistory.UnidentifiedSprite,
			&i.ItemHistory.SlotCount,
			&i.ItemHistory.IsBook,
			&i.ItemHistory.CanUseBuyingStore,
			&i.ItemHistory.CardPrefix,
			&i.ItemHistory.CardIsPostfix,
			&i.ItemHistory.CardIllustration,
			&i.ItemHistory.ClassNum,
			&i.ItemHistory.IsCostume,
			&i.ItemHistory.EffectID,
			&i.ItemHistory.PackageID,
			&i.ItemHistory.MoveInfo,
			&i.PreviousItemHistoryVw.HistoryID,
			&i.PreviousItemHistoryVw.PreviousHistoryID,
			&i.PreviousItemHistoryVw.ItemID,
			&i.PreviousItemHistoryVw.FileVersion,
			&i.PreviousItemHistoryVw.Update,
			&i.PreviousItemHistoryVw.IdentifiedName,
			&i.PreviousItemHistoryVw.IdentifiedDescription,
			&i.PreviousItemHistoryVw.IdentifiedSprite,
			&i.PreviousItemHistoryVw.UnidentifiedName,
			&i.PreviousItemHistoryVw.UnidentifiedDescription,
			&i.PreviousItemHistoryVw.UnidentifiedSprite,
			&i.PreviousItemHistoryVw.SlotCount,
			&i.PreviousItemHistoryVw.IsBook,
			&i.PreviousItemHistoryVw.CanUseBuyingStore,
			&i.PreviousItemHistoryVw.CardPrefix,
			&i.PreviousItemHistoryVw.CardIsPostfix,
			&i.PreviousItemHistoryVw.CardIllustration,
			&i.PreviousItemHistoryVw.ClassNum,
			&i.PreviousItemHistoryVw.IsCostume,
			&i.PreviousItemHistoryVw.EffectID,
			&i.PreviousItemHistoryVw.PackageID,
			&i.PreviousItemHistoryVw.MoveInfo,
			&i.Lastupdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentItems = `-- name: GetCurrentItems :many
SELECT item_history.history_id, item_history.previous_history_id, item_history.item_id, item_history.file_version, item_history.` + "`" + `update` + "`" + `, item_history.identified_name, item_history.identified_description, item_history.identified_sprite, item_history.unidentified_name, item_history.unidentified_description, item_history.unidentified_sprite, item_history.slot_count, item_history.is_book, item_history.can_use_buying_store, item_history.card_prefix, item_history.card_is_postfix, item_history.card_illustration, item_history.class_num, item_history.is_costume, item_history.effect_id, item_history.package_id, item_history.move_info, ` + "`" + `items` + "`" + `.` + "`" + `deleted` + "`" + `
FROM ` + "`" + `items` + "`" + `
INNER JOIN ` + "`" + `item_history` + "`" + ` ON ` + "`" + `items` + "`" + `.` + "`" + `latest_history_id` + "`" + ` = ` + "`" + `item_history` + "`" + `.` + "`" + `history_id` + "`" + `
`

type GetCurrentItemsRow struct {
	HistoryID               int32
	PreviousHistoryID       sql.NullInt32
	ItemID                  int32
	FileVersion             int32
	Update                  string
	IdentifiedName          sql.NullString
	IdentifiedDescription   sql.NullString
	IdentifiedSprite        sql.NullString
	UnidentifiedName        sql.NullString
	UnidentifiedDescription sql.NullString
	UnidentifiedSprite      sql.NullString
	SlotCount               int8
	IsBook                  bool
	CanUseBuyingStore       bool
	CardPrefix              sql.NullString
	CardIsPostfix           bool
	CardIllustration        sql.NullString
	ClassNum                sql.NullInt32
	IsCostume               bool
	EffectID                int32
	PackageID               int32
	MoveInfo                []byte
	Deleted                 bool
}

func (q *Queries) GetCurrentItems(ctx context.Context) ([]GetCurrentItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCurrentItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCurrentItemsRow
	for rows.Next() {
		var i GetCurrentItemsRow
		if err := rows.Scan(
			&i.HistoryID,
			&i.PreviousHistoryID,
			&i.ItemID,
			&i.FileVersion,
			&i.Update,
			&i.IdentifiedName,
			&i.IdentifiedDescription,
			&i.IdentifiedSprite,
			&i.UnidentifiedName,
			&i.UnidentifiedDescription,
			&i.UnidentifiedSprite,
			&i.SlotCount,
			&i.IsBook,
			&i.CanUseBuyingStore,
			&i.CardPrefix,
			&i.CardIsPostfix,
			&i.CardIllustration,
			&i.ClassNum,
			&i.IsCostume,
			&i.EffectID,
			&i.PackageID,
			&i.MoveInfo,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemHistory = `-- name: GetItemHistory :many
SELECT current.history_id, current.previous_history_id, current.item_id, current.file_version, current.` + "`" + `update` + "`" + `, current.identified_name, current.identified_description, current.identified_sprite, current.unidentified_name, current.unidentified_description, current.unidentified_sprite, current.slot_count, current.is_book, current.can_use_buying_store, current.card_prefix, current.card_is_postfix, current.card_illustration, current.class_num, current.is_costume, current.effect_id, current.package_id, current.move_info, previous.history_id, previous.previous_history_id, previous.item_id, previous.file_version, previous.` + "`" + `update` + "`" + `, previous.identified_name, previous.identified_description, previous.identified_sprite, previous.unidentified_name, previous.unidentified_description, previous.unidentified_sprite, previous.slot_count, previous.is_book, previous.can_use_buying_store, previous.card_prefix, previous.card_is_postfix, previous.card_illustration, previous.class_num, previous.is_costume, previous.effect_id, previous.package_id, previous.move_info
FROM ` + "`" + `item_history` + "`" + ` current
LEFT JOIN ` + "`" + `previous_item_history_vw` + "`" + ` previous ON ` + "`" + `previous` + "`" + `.` + "`" + `history_id` + "`" + ` = ` + "`" + `current` + "`" + `.` + "`" + `previous_history_id` + "`" + `
WHERE ` + "`" + `current` + "`" + `.` + "`" + `item_id` + "`" + ` = ?
ORDER BY ` + "`" + `current` + "`" + `.` + "`" + `history_id` + "`" + ` ASC
LIMIT ?, ?
`

type GetItemHistoryParams struct {
	ItemID int32
	Offset int32
	Limit  int32
}

type GetItemHistoryRow struct {
	ItemHistory           ItemHistory
	PreviousItemHistoryVw PreviousItemHistoryVw
}

func (q *Queries) GetItemHistory(ctx context.Context, arg GetItemHistoryParams) ([]GetItemHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getItemHistory, arg.ItemID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemHistoryRow
	for rows.Next() {
		var i GetItemHistoryRow
		if err := rows.Scan(
			&i.ItemHistory.HistoryID,
			&i.ItemHistory.PreviousHistoryID,
			&i.ItemHistory.ItemID,
			&i.ItemHistory.FileVersion,
			&i.ItemHistory.Update,
			&i.ItemHistory.IdentifiedName,
			&i.ItemHistory.IdentifiedDescription,
			&i.ItemHistory.IdentifiedSprite,
			&i.ItemHistory.UnidentifiedName,
			&i.ItemHistory.UnidentifiedDescription,
			&i.ItemHistory.UnidentifiedSprite,
			&i.ItemHistory.SlotCount,
			&i.ItemHistory.IsBook,
			&i.ItemHistory.CanUseBuyingStore,
			&i.ItemHistory.CardPrefix,
			&i.ItemHistory.CardIsPostfix,
			&i.ItemHistory.CardIllustration,
			&i.ItemHistory.ClassNum,
			&i.ItemHistory.IsCostume,
			&i.ItemHistory.EffectID,
			&i.ItemHistory.PackageID,
			&i.ItemHistory.MoveInfo,
			&i.PreviousItemHistoryVw.HistoryID,
			&i.PreviousItemHistoryVw.PreviousHistoryID,
			&i.PreviousItemHistoryVw.ItemID,
			&i.PreviousItemHistoryVw.FileVersion,
			&i.PreviousItemHistoryVw.Update,
			&i.PreviousItemHistoryVw.IdentifiedName,
			&i.PreviousItemHistoryVw.IdentifiedDescription,
			&i.PreviousItemHistoryVw.IdentifiedSprite,
			&i.PreviousItemHistoryVw.UnidentifiedName,
			&i.PreviousItemHistoryVw.UnidentifiedDescription,
			&i.PreviousItemHistoryVw.UnidentifiedSprite,
			&i.PreviousItemHistoryVw.SlotCount,
			&i.PreviousItemHistoryVw.IsBook,
			&i.PreviousItemHistoryVw.CanUseBuyingStore,
			&i.PreviousItemHistoryVw.CardPrefix,
			&i.PreviousItemHistoryVw.CardIsPostfix,
			&i.PreviousItemHistoryVw.CardIllustration,
			&i.PreviousItemHistoryVw.ClassNum,
			&i.PreviousItemHistoryVw.IsCostume,
			&i.PreviousItemHistoryVw.EffectID,
			&i.PreviousItemHistoryVw.PackageID,
			&i.PreviousItemHistoryVw.MoveInfo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemIdsInUpdate = `-- name: GetItemIdsInUpdate :many
SELECT ` + "`" + `item_history` + "`" + `.` + "`" + `history_id` + "`" + `, ` + "`" + `item_history` + "`" + `.` + "`" + `item_id` + "`" + `
FROM ` + "`" + `item_history` + "`" + `
WHERE ` + "`" + `item_history` + "`" + `.` + "`" + `update` + "`" + ` = ?
`

type GetItemIdsInUpdateRow struct {
	HistoryID int32
	ItemID    int32
}

func (q *Queries) GetItemIdsInUpdate(ctx context.Context, update string) ([]GetItemIdsInUpdateRow, error) {
	rows, err := q.db.QueryContext(ctx, getItemIdsInUpdate, update)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemIdsInUpdateRow
	for rows.Next() {
		var i GetItemIdsInUpdateRow
		if err := rows.Scan(&i.HistoryID, &i.ItemID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemList = `-- name: GetItemList :many
SELECT ` + "`" + `item_history` + "`" + `.` + "`" + `item_id` + "`" + `, ` + "`" + `item_history` + "`" + `.` + "`" + `identified_name` + "`" + `, ` + "`" + `item_history` + "`" + `.` + "`" + `update` + "`" + ` lastUpdate
FROM ` + "`" + `items` + "`" + `
INNER JOIN ` + "`" + `item_history` + "`" + ` ON ` + "`" + `item_history` + "`" + `.` + "`" + `history_id` + "`" + ` = ` + "`" + `items` + "`" + `.` + "`" + `latest_history_id` + "`" + `
WHERE ` + "`" + `items` + "`" + `.` + "`" + `deleted` + "`" + ` = FALSE
ORDER BY ` + "`" + `item_history` + "`" + `.` + "`" + `item_id` + "`" + ` ASC
LIMIT ?, ?
`

type GetItemListParams struct {
	Offset int32
	Limit  int32
}

type GetItemListRow struct {
	ItemID         int32
	IdentifiedName sql.NullString
	Lastupdate     string
}

func (q *Queries) GetItemList(ctx context.Context, arg GetItemListParams) ([]GetItemListRow, error) {
	rows, err := q.db.QueryContext(ctx, getItemList, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemListRow
	for rows.Next() {
		var i GetItemListRow
		if err := rows.Scan(&i.ItemID, &i.IdentifiedName, &i.Lastupdate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertItem = `-- name: UpsertItem :execresult
INSERT INTO ` + "`" + `items` + "`" + ` (` + "`" + `item_id` + "`" + `, ` + "`" + `latest_history_id` + "`" + `, ` + "`" + `deleted` + "`" + `)
VALUES (?, ?, ?)
ON DUPLICATE KEY UPDATE
	latest_history_id = VALUES(latest_history_id),
	deleted = VALUES(deleted)
`

type UpsertItemParams struct {
	ItemID          int32
	LatestHistoryID int32
	Deleted         bool
}

func (q *Queries) UpsertItem(ctx context.Context, arg UpsertItemParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, upsertItem, arg.ItemID, arg.LatestHistoryID, arg.Deleted)
}
